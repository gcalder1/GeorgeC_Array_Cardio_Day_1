<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Array Cardio üí™</title>
  <link rel="icon" href="https://fav.farm/üî•" />
</head>
<body>
  <p><em>Psst: have a look at the JavaScript Console</em> üíÅ</p>
  <script>
    // Get your shorts on - this is an array workout!
    // ## Array Cardio Day 1

    // Some data we can work with

    const inventors = [
      { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },
      { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 },
      { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 },
      { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 },
      { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 },
      { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 },
      { first: 'Max', last: 'Planck', year: 1858, passed: 1947 },
      { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 },
      { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 },
      { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 },
      { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 },
      { first: 'Hanna', last: 'Hammarstr√∂m', year: 1829, passed: 1909 }
    ];

    const people = [
      'Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig',
      'Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving',
      'Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano',
      'Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose',
      'Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank'
    ];
    
    // Array.prototype.filter()
    // 1. Filter the list of inventors for those who were born in the 1500's
    
    const fifteen = inventors.filter(inventor => (inventor.year >= 1500 && inventor.year < 1600))
    
    //using arrow function to write in one line - returns boolean value of true
    //in the same way
    
    console.table(fifteen);

    /* +++++My Notes: .filter()+++++
    
    The filter method can be used to return a shallow copy of your data
    with the elements from the original array that return truthy based on the
    condition referenced. The reason this could be useful is because it can
    ignore elements that do NOT meet the requirements of the condition used 
    as the filter, therefore allowing us to have a stored, shallow copy of that
    new array. In terms of ignore elements, what that means is that they
    WILL NOT be included within the new array if they return falsy (if its
    an empty string, a null, an undefined, or a 0).
    
    If we were to edit the original array, the filtered array would
    then reflect those changes since the shallow copy is copying the original
    elements that return truthy for your condition of your filter. However,
    shallow copies DO NOT take on nested values but only superficial, outter
    values of arrays.
    
    And because the elements that return as truthy will be stored within that new shallow
    copy of the array, if we were to console.log (or console table for arrays
    that have objects) that array, we would only those same values that return
    as truthy and not the original array.
    
    */


    // Array.prototype.map()
    // 2. Give us an array of the inventors first and last names

    const fullNames = inventors.map(inventor => `${inventor.first} ${inventor.last}`);
    console.log(fullNames);
    // console.table(fullNames); <- MAkes info easier to see

    /* +++++My notes: .map()+++++

    .map() is a method that iterates through each object within an array and
    applies whatever function was declared for it. The result from this is
    a new array in the form of a shallow copy based on the original array,
    where the objects within the new array have been altered by whatever
    function was declared within the method's function call. The amount of
    objects returned will always be the same amount of objects as in the
    original array because it does not affect the original array but instead
    only affects what is shown in that copy(does not mutate OG array). 

    This can help with returning outputs of data that are relevant to each 
    other since the quanitity of elements returned will be the same, only changing
    those that are "changable" by your function. This does NOT mean that the
    elements that return as falsy DO NOT appear within the new array, but rather
    they are shown as they were, left untouched/unchanged. This way, all
    objects available within the OG array will still be mapped on the new array 
    (meaning things like sparse arrays with empty elements will work but the 
    element will appear as empty or null or 0, etc.)

    If the function concatenates or uses a template literal to interpolate the
    elements into a string, then you can still return or print those objects as
    a string within that new array becuase those elements are still available but
    changed based on the function provided.

    e.g. 
    const colorProfile = [
    {colorMain: 'red', colorSub: 'blue'},
    {colorMain: 'blue', colorSub: 'green'},
    {colorMain: 'green', colorSub: 'white'},
    {colorMain: 'white', colorSub: 'red'},
    {colorMain: 'blue', colorSub: 'black'}
    ];

  const colorCombo = colorProfile.map(color => 
    `Although I do like ${color.colorSub}, my favorite color is ${color.colorMain}`);
    console.table(colorCombo);

    */

    // Array.prototype.sort()
    // 3. Sort the inventors by birthdate, oldest to youngest

    // const ordered = inventors.sort(function(firstPerson, secondPerson) {
    //   if (firstPerson.year > secondPerson.year) {
    //     return 1; //because firstPerson would return a 1, this would make it
    //     //less than, therefore allowing first person to appear after. 
    //   } else {
    //     return -1; //because first person would return a -1 instead, this
    //     //would make a less than b therefore allowing first-person to 
    //     //appear before since the method checks against 0.
    //   }
    // });

    const ordered = inventors.sort((firstPerson, secondPerson) => firstPerson.year > secondPerson.year ? 1 : -1);

    console.table(ordered);

    /* +++++My notes: .sort()+++++

    .sort() applies changes to the original data structure based on the
    function called. This means that it DOES NOT use a copy of the data.
    Since it is using the OG array's elements, then any changes would affect
    other things that would make copies of the OG's array's data set.

    .sort() organizes based on what criteria the method of the function you 
    provide has when called. Based on what the function finds is true, then
    that will determine the order of said array elements by either assigning
    it a -1 or 1 (or 0 if both elements are found to be absolutely equal).

    (e.g: 
    
    if a > b -> return 1; means that a will go after b in the newly sorted array
    
    if a < b -> return -1; means that a will go before b in the newly sorted array
    
    if a === b -> return 0; means that no order change will occur

    If no function was declared, then the elements would be sorted in an ascending order.
    If the array's elements were numbers, then they'll just be sorted 
    numerically that way. 

    e.g. console.log(sortedNums); // [1, 20, 33, 46, 89, 101]
    
    If they were strings, then the array would be sorted based 
    on their unicode values in the same ascending order. 

    e.g.  const stringString = ["hello", "goodbye", "cheese", "water", "dog"];
          stringString.sort();
          console.log(sortedStrings); // ["cheese", "dog", "goodbye", "hello", "water"]

    The .sort() has some default stuff it relies on incase something like 
    this would happen.
    
    */


    // Array.prototype.reduce()
    // 4. How many years did all the inventors live all together?

    const totalYears = inventors.reduce((total, inventor) => {
      return total + (inventor.passed - inventor.year);
    }, 0);

    console.log(totalYears);

    /*+++++My notes: .reduce()+++++
    
    .reduce() is a method that takes a function and pushes it through the two
    specified variables within that method. With one variable being
    the initialized amount (where the reduce method will begin) and the 
    second variable being the way that it accumulates (the way it will change),
    the returned value will be the sequential combination of the element on the
    index we're at with the element of the index that is next in the iteration.
    This culminates to a returned value that is ONLY received after the final
    iteration, which would be the combined result of the current value and the
    accumulator. This value does not change anything within the array itself
    nor does it make a copy of the array in any way, but instead outputs that
    "reduced" value.

    If no initial value is provided, the .reduce() method takes the value of
    the index of zero regardless BUT starts the iteration at the index of 1
    meaning that it will take the combined values of both as specified by
    the function provided. If not provided with any function, then we will
    get an error. If no array is provided, then we'll also get an error 
    because reduce() needs something to start off on to iterate through.

    With this in mind, it is important to remember that the .reduce() 
    method will not return an object or an array since it is returning the
    culmination of all of your values per the initialized value, the 
    accumulator, and the specified function's method ALL in a single value.

    */


    // 5. Sort the inventors by years lived

    const oldest = inventors.sort(function(a, b){
      const lastGuy = a.passed - a.year;
      const nextGuy = b.passed - b.year;

      return lastGuy > nextGuy ? -1 : 1;

      // if (lastGuy > nextGuy){ //using ternary operator instead for simple 2-part condition
      //   return -1;
      // }

      // else {
      //   return 1;
      // }
    });
    console.table(oldest);


    // 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name
    // https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris

    /*
    const category = document.querySelector('.mw-category'); //targetting the element that contains the list
    const links = Array.from(category.querySelectorAll('a')); //creates an array out of your node list (in this case, the links)
    const de = links
                    .map(link => link.textContent) //maps the text from the links without mapping the actual nested things
                    .filter(streetName => streetName.includes('de')); // creates a shallow copy containing things that fit the parameter of the .includes method which is "de", therefore
                                                                      // only showing us the new array with the text that contains "de"
                                                                      // Side Note: It didn't occur to me that you could just use array methods one after the other: .map().filter(), etc..

    */

    // 7. sort Exercise
    // Sort the people alphabetically by last name

    const alphabeticalOrder = people.sort(function(lastOne, nextOne){ // => to replace function after both parameters
      const [aLast, aFirst] = lastOne.split(', '); //using these to define 
      const [bLast, bFirst] = nextOne.split(', ');//the conversion
      if (aLast > bLast){
        return 1;
      } else {
        return -1;
      }
    });
    console.log(alphabeticalOrder);
    /*
    We use .split() here to split the the string into seperate strings within 
    the same copy of the array, avoiding modifying the original array. This method
    returns a new array as well, containing the defined split method applied to the
    original array. What we get instead of the original array is a copy with .split()
    parameter applied to the elements within the array.

    In this case, since we had a string of a last name and first name, we needed a 
    way to actually use those, which is why we had to convert the OG strings into
    new usable elements.
    */


    // 8. Reduce Exercise
    // Sum up the instances of each of these

    const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck' ];

    const transportation = data.reduce(function(obj, item){ // 
      if(!obj[item]){ //if there is no object item, then sets the object item to 0 (initializer)
       
        obj[item] = 0;
      }
      
      obj[item]++; //As is it going through the array, if it finds that object item, then increases the item of the object by 1 (in this case the item is the amount of times it is seen)
      return obj; //Returns the new object at its amount (wouldn't do obj[item] because we're not trying to access what is inside of truck since it would return a reference error)
    }, {}); //iterates through entire array
    
    console.log(transportation); //Shows new values. Does not change array since .reduce() only displays values of reduce method actually applying


  </script>
</body>
</html>
